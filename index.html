<!doctype html><html><head><meta name=generator content="Hugo 0.110.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Zhengdong.jzd 个人博客 | Home</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta property="og:image" content><link rel=alternate type=application/rss+xml href=http://xautjzd.github.io/index.xml title="Zhengdong.jzd 个人博客"><meta property="og:title" content="Zhengdong.jzd 个人博客"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://xautjzd.github.io/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Zhengdong.jzd 个人博客"><meta name=twitter:description content><script src=http://xautjzd.github.io/js/feather.min.js></script>
<link href=http://xautjzd.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=http://xautjzd.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><div class=main><a href=http://xautjzd.github.io/>Zhengdong.jzd 个人博客</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/tags>Tags</a></nav></header><main class=list><div class=site-description></div><section class=list-item><h1 class=title><a href=/posts/use-brewfile-to-automation/>MacOS 环境批量安装软件</a></h1><time>Jan 19, 2023</time><br><div class=description>最近工作使用的电脑新换到 MacBook Pro M1 13寸，平时工作使用的各种工具 & 软件都需要重新安装 & 配置，耗时耗力而且没有太多成就感，所以一直在思索如何将其自动化掉，避免每次换电脑都要做重复的劳动。自己平时安装各种软件比较依赖 HomeBrew，印象中它有提供 Brewfile 可以批量安装软件，只是自己一直没有使用起来。刚好趁这次机会拿来练练手，一来总结经验以备下次复用，二来分享出来希望可以帮助到他人。下面分享下我是如何使用 Brewfile 批量安装工作必备软件的。
1. 前提 使用 Brewfile 进行批量安装前，需要安装：
git HomeBrew 另外若在 Brewfile 中指定 mas 从 AppleStore 安装软件，请保证 AppleID 已登录。
2. 列出所需软件清单，形成 Brewfile 在批量安装前，列出自己平时工作所需的软件，在任意目录下创建名为 Brewfile 的文件，文件内容及格式可以参考我目前使用的 Brewfile 来声明:
# taps tap "homebrew/bundle" tap "homebrew/cask" tap "homebrew/core" # packages brew 'vim' brew 'git' brew 'zsh' brew 'tmux' brew 'ripgrep' brew 'bat' brew 'helix' brew 'jq' brew 'mas' # tools cask 'emacs' cask 'google-chrome' cask 'notion' cask 'alfred' cask 'warp' cask 'intellij-idea-ce' cask 'sequel-pro' cask 'clashx' cask 'tunnelblick' # language # cask 'java' brew 'go' brew 'cmake' brew 'maven' brew 'yarn' # install apps from apple store: 1.&mldr;</div><a class=readmore href=/posts/use-brewfile-to-automation/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2022-08-18-how-dns-works/>域名是如何解析的？</a></h1><time>Aug 18, 2022</time><br><div class=description><h2 id=基本概念>基本概念</h2><p>我们生活在互联网时代，每天的工作生活几乎都在与互联网打交道，比如使用 Google 查找工作学习所需资料，使用 Youtube、抖音、网易云音乐等进行娱乐活动，通过 Twitter、微博、微信等获取新闻资讯及社交，使用京东、天猫、拼多多等购物，使用微信支付、支付宝支付进行付款等，这些都离不开网络。那么作为构成网络基础设施核心之一的域名(Domain)你知道是如何工作的吗？下面我们简单展开介绍下。</p><p>所有的信息都存储在服务器上，可通过 IP 地址访问获取，但通常 IP 地址难以记住，于是乎产生了域名概念。起初网络仅有少数服务器构成，域名到 IP 的映射信息可存储在单个文件(eg: /etc/hosts)，随着网络的蓬勃发展，单文件难以容纳所有的域名IP 映射关系，同时映射关系变更时，难以及时同步至各服务器，于是 <a href=https://en.wikipedia.org/wiki/Domain_Name_System>DNS(Domain Name System) 协议</a>诞生，映射关系通过 DNS 服务器集中存储，用户根据所需向 DNS 服务器查询。那么 DNS 服务器是如何来存储域名映射关系的呢？这个映射关系是谁来负责写入的呢？下面来揭晓。</p>&mldr;</div><a class=readmore href=/posts/2022-08-18-how-dns-works/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2022-08-04-emacs-basic-operation/>Emacs 常用基本操作</a></h1><time>Aug 4, 2022</time><br><div class=description><p>Emacs 作为 Programmer 熟知的两大 Editor 之一流行了很多年了，据说学习曲线陡峭，一直处于劝退状态。但作为喜欢折腾各种工具的自己来说，内心一直有跃跃欲试的想法，终于最近两个月得闲，开始研究学习上了。通过学习<a href=https://www.gnu.org/software/emacs/manual/html_node/emacs/index.html>官网Tutorials</a> 熟悉其基本操作 & 配置，同时 Google 了解 Emacs 使用频次最高的一些插件，在使用过程中不断优化配置，打造成自己趁手的工具。目前，我主要有三种使用场景: 1. 文本编辑 2. 代码阅读 3. 写业余代码。以下是我在学习过程中整理的常用基本操作，分享出来一方面是当作学习笔记输出，以便后续遗忘时快速查找，另一方面也希望能带给他人一些帮助。</p><p>目前的常用操作有：</p><ul><li>单文件操作</li><li>光标移动</li><li>复制(copy) & 粘贴(paste)</li><li>插入(insert) & 删除(delete)</li><li>撤销(undo) & 重做(redo)</li><li>窗口操作</li><li>阅读代码常用操作</li><li>查看帮助文档</li></ul><p>在使用 Emacs 时，有几个关键概念:</p><ul><li>Buffer</li><li>Window</li><li>Frame</li><li>Mode</li></ul><p>请自行查阅文档了解。</p><blockquote><p><strong>注：</strong><code>C-h</code> 表示按住 Ctrl 键的同时按 h 键；<code>M-x</code> 表示按住 Alt/Meta 键的同时按 x 键; <code>S-p f</code> 表示按住 Windows 键，再依次按 p f 键。</p></blockquote>&mldr;</div><a class=readmore href=/posts/2022-08-04-emacs-basic-operation/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2022-01-06-mysql-optimizing/>MySQL 数据库优化</a></h1><time>Jan 6, 2022</time><br><div class=description>MySQL 数据库优化可从以下方面着手：
SQL 语句优化 索引优化 锁优化 缓存优化 InnoDB 存储引擎优化 1. SQL 语句优化 检查 select 的 where 条件是否走索引，可用 explain 查看。 最小化全表扫描次数。 定期使用 ANALYZE TABLE 以保持表的统计信息是最新的。 更多，请参考: https://dev.mysql.com/doc/refman/8.0/en/select-optimization.html
2. 索引优化 参考: https://dev.mysql.com/doc/refman/8.0/en/optimization-indexes.html
3. 锁优化 参考: https://dev.mysql.com/doc/refman/5.7/en/locking-issues.html
4. 缓存优化 参考: https://dev.mysql.com/doc/refman/5.7/en/buffering-caching.html
5. InnoDB 存储引擎优化 5.1 InnoDB 存储磁盘 I/O 优化 5.1.1 参数 innodb_buffer_pool_size innodb_buffer_pool_size 一般调为系统内存的 50%~75%。
5.1.2 参数 innodb_flush_method InnoDB 默认为 fsync，但在一些 GNU/Linux 或 Unix 发行版下，fsync 刷新缓存文件至磁盘非常慢，可将 innodb_flush_method 调整为 O_DSYNC。
5.1.3 参数 innodb-fsync-threshold InnoDB 默认为 0，可调整 innodb 缓存阈值，避免单次大文件缓存刷盘。&mldr;</div><a class=readmore href=/posts/2022-01-06-mysql-optimizing/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2021-04-11-learning-plan/>2021 专业技能学习计划</a></h1><time>Apr 11, 2021</time><br><div class=description><p>时常觉得自己看过的东西不少，但却没有很好地沉淀，主要有两方面弊端：1. 自我怀疑 花了不少时间学习了解，长时间不用，缺少实战经验，最终慢慢遗忘，最后会疑惑自己的时间花的到底值不值？为何要浪费时间在没有任何产出上？2. 没有形成知识面 最近两年很少系统地去学习知识，大部分时间花费在了碎片式学习上，东边一榔头，西边一棒槌，都是分散的知识点，很少总结回顾，沉淀成文字/视频等，导致后面用到时，重复浪费时间在资料查询搜集上，不能很好地缩短自己重拾知识时间，也未能很好地帮助他人。为此，这里特梳理下自己 2021 年的学习计划，形成知识索引，方面后续知识快速定位，也希望能给予他人一点点帮助。</p><ul><li>操作系统: 重点是Linux 进程管理 & 调度、进程间通信、内存管理、I/O 模型</li><li>网络: TCP/IP 协议、HTTP 协议、DNS 协议、容器网络</li><li>中间件: Redis, RabbitMQ/Kafka/RocketMQ, Nginx, Zookeeper/Etcd, ElasticSearch, MySQL</li><li>设计原则 & 设计模式: SOLID, 24 种设计模式</li><li>系统架构: Client/Server, MVC, Layer, Broker 等</li><li>语言: Java/Go/Rust</li><li>工具: 效率提升类, 问题定位分析类, 知识变现类</li><li>其他: Google Analysis, 百度统计、SEO 相关</li></ul>&mldr;</div><a class=readmore href=/posts/2021-04-11-learning-plan/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2020-09-08-what-is-file-system/>什么是文件系统？</a></h1><time>Sep 8, 2020</time><br><div class=description>文件系统是什么？ 文件系统组成 如何写一个简单的文件系统 文件系统是什么？ 软件 记录文件元信息(文件大小，所属用户，包含块等) 文件系统组成 inode inode 记录着文件的元信息，包含以下部分:
文件大小 组件文件的块(block) 属主(owner) 访问权限 访问时间 创建时间 修改时间 inode table 为了管理 inode 信息，需要有个数据数据结构存储 inode 信息, 称之为 inode table, 会占一部分磁盘空间，若 inode 大小为 256 bytes, 一个 4k 大小的 block 可存储 16 个 inodes。
allocation list 为了管理 block 是否已分配，需要有个数据结构存储，通常可以用位图(bitmap) 算法进行存储, 用 1bit 表示该 block 是否已使用，一个 4k 大小的 block 可存储 32k 个 block 使用情况。
superblock superblock 用于存储文件系统元信息，包括 inodes 数量、文件系统中数据块(data block)数量、inode table 起始块位置、用于标识文件系统类型的魔数(magic number)等。操作系统挂载文件系统时，会首先读取 superblock 信息。&mldr;</div><a class=readmore href=/posts/2020-09-08-what-is-file-system/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2020-09-01-how-java-jar-works/>Java jar 是如何执行的?</a></h1><time>Sep 1, 2020</time><br><div class=description><p>Java 作为一门古老又流行的编程语言，想必大家或多或少都听过，甚至使用过，也有一部分人甚至在生产环境部署过 java 应用。可你了解过 java 程序是如何加载运行的吗？如果你的答案是 <code>yes</code>, 那么建议不用浪费时间花费在已知的知识点了。</p><p>下面主要针对 java 可执行 jar(还有有库类型的jar 包，eg: rt.jar) 分析 jar 的加载运行过程，主要包含以下三部分展开:</p><ul><li>Java jar 生成</li><li>Java jar 内容</li><li>Java jar 加载 & 运行</li></ul>&mldr;</div><a class=readmore href=/posts/2020-09-01-how-java-jar-works/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2019-10-21-ip-location/>IP 归属地查询</a></h1><time>Oct 21, 2019</time><br><div class=description><p>这里分享下几个不错的 ip 地址库:</p><h2 id=1-httpsipcnhttpsipcn>1. <a href=https://ip.cn>https://ip.cn</a></h2><h3 id=查询指定-ip>查询指定 IP</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>curl https://ip.cn?ip=202.200.112.2
</span></span></code></pre></div><h3 id=查询本机-ip>查询本机 IP</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>curl https://ip.cn
</span></span></code></pre></div><p><strong>优势</strong>: 国内服务，速度较快, 且免费</p><p><strong>劣势</strong>: 信息量太少, 没有经纬度信息</p>&mldr;</div><a class=readmore href=/posts/2019-10-21-ip-location/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2019-10-20-go-app-version/>Go 二进制应用注入 version 信息</a></h1><time>Oct 20, 2019</time><br><div class=description><p>当线上服务出现问题时，在排查问题前，我们需要确定线上服务部署版本、对应源码分支、最近一次提交记录、编译/打包时间、语言版本等，这些信息可写入配置文件，应用启动时读取。若采用 docker 部署时，也可将这些信息作为 LABEL 或应用镜像的 tag 中，方式多种多样，今天要介绍的是 go 应用下的另一个可选方式: 二进制编译时注入。</p>&mldr;</div><a class=readmore href=/posts/2019-10-20-go-app-version/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2015-06-01-build-shadowsocks-on-ubuntu/>Ubuntu14.04上搭建ShadowSocks服务</a></h1><time>Jun 1, 2015</time><br><div class=description><p><img src=/images/20150601.jpg alt></p><h2 id=1-vps选择>1. VPS选择</h2><p>之前一直使用GoAgent作为破墙工具，不过后来有一阵用不成，即使更新到最新版，也未能如愿，后来忙于写论文，便用微软的<a href=http://www.bing.com/>Bing</a>临时代替Google。用了一阵Bing,发现其实也挺好用，无论是UI还是搜索内容，都相当不错。只是偶尔想呼吸墙外空气，却未能如愿，始终给人不快的感觉。所以便有意选择付费服务。一直听说ShadowSocks搭建代理特别稳定，便开始留意VPS。可选的VPS很多，比较流行的当属Linode和Digital Ocean,不过Linode服务实在是太贵了，且最低配都感觉有点大材小用，没必要这么奢侈。便着重关注了下DO。可选的VPS有：</p>&mldr;</div><a class=readmore href=/posts/2015-06-01-build-shadowsocks-on-ubuntu/>Read more ⟶</a></section><ul class=pagination><span class="page-item page-prev"></span><span class="page-item page-next"><a href=/page/2/ class=page-link aria-label=Next><span aria-hidden=true>Next →</span></a></span></ul></main><footer><div style=display:flex><a class=soc href=https://github.com/xautjzd rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/xautjzd/ rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2023 © jzd | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>