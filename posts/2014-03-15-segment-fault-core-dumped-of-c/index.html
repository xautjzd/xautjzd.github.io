<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>C语言中的Segment fault问题 - Zhengdong.jzd 个人博客</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="![](img /images/20140315.jpg)
什么是Segment fault?

a segmentation fault (often shortened to segfault) or access violation is a fault raised by hardware with memory protection, notifying an operating system (OS) about a memory access violation; on x86 computers this is a form of general protection fault.

以上为Wikipedia对段错误的解释。用通俗易懂的话来说就是访问越界，访问了不存在或者受操作系统保护的内存，通常都是由于数组越界或者指针引起。
产生段错误的原因

dereferencing NULL
dereferencing an uninitialized pointer
deferencing a pointer that has been freed/out of scope
writing off the end of an array
recursive function that uses all of the stack space
"><meta property="og:image" content><meta property="og:title" content="C语言中的Segment fault问题"><meta property="og:description" content="![](img /images/20140315.jpg)
什么是Segment fault?

a segmentation fault (often shortened to segfault) or access violation is a fault raised by hardware with memory protection, notifying an operating system (OS) about a memory access violation; on x86 computers this is a form of general protection fault.

以上为Wikipedia对段错误的解释。用通俗易懂的话来说就是访问越界，访问了不存在或者受操作系统保护的内存，通常都是由于数组越界或者指针引起。
产生段错误的原因

dereferencing NULL
dereferencing an uninitialized pointer
deferencing a pointer that has been freed/out of scope
writing off the end of an array
recursive function that uses all of the stack space
"><meta property="og:type" content="article"><meta property="og:url" content="https://xautjzd.github.io/posts/2014-03-15-segment-fault-core-dumped-of-c/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-03-15T00:00:00+00:00"><meta property="article:modified_time" content="2014-03-15T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C语言中的Segment fault问题"><meta name=twitter:description content="![](img /images/20140315.jpg)
什么是Segment fault?

a segmentation fault (often shortened to segfault) or access violation is a fault raised by hardware with memory protection, notifying an operating system (OS) about a memory access violation; on x86 computers this is a form of general protection fault.

以上为Wikipedia对段错误的解释。用通俗易懂的话来说就是访问越界，访问了不存在或者受操作系统保护的内存，通常都是由于数组越界或者指针引起。
产生段错误的原因

dereferencing NULL
dereferencing an uninitialized pointer
deferencing a pointer that has been freed/out of scope
writing off the end of an array
recursive function that uses all of the stack space
"><script src=https://xautjzd.github.io/js/feather.min.js></script>
<link href=https://xautjzd.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://xautjzd.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><div class=main><a href=https://xautjzd.github.io/>Zhengdong.jzd 个人博客</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>C语言中的Segment fault问题</h1><div class=meta>Posted on Mar 15, 2014</div></div><section class=body><p>![](img /images/20140315.jpg)</p><h2 id=什么是segment-fault>什么是Segment fault?</h2><blockquote><p>a segmentation fault (often shortened to segfault) or access violation is a fault raised by hardware with memory protection, notifying an operating system (OS) about a memory access violation; on x86 computers this is a form of general protection fault.</p></blockquote><p>以上为<a href=http://en.wikipedia.org/wiki/Segmentation_fault>Wikipedia</a>对段错误的解释。用通俗易懂的话来说就是访问越界，访问了不存在或者受操作系统保护的内存，通常都是由于数组越界或者指针引起。</p><h2 id=产生段错误的原因>产生段错误的原因</h2><ol><li>dereferencing NULL</li><li>dereferencing an uninitialized pointer</li><li>deferencing a pointer that has been freed/out of scope</li><li>writing off the end of an array</li><li>recursive function that uses all of the stack space</li></ol><h2 id=什么是core文件>什么是core文件？</h2><p>在调试段错误前，不得不提到core文件。那么什么是core文件呢?core文件其实就是当程序崩溃时保存的该进程在内存中的映像(同时包含调试信息),主要用于调试。</p><h2 id=如何调试>如何调试？</h2><p>像VS等IDE集成度太高，在方便快捷的同时也会将人培养成傻瓜，培养成码农。所以要想抱着以学习的心态来学习，最好转到Linux/Mac OS平台下，通过gcc/cmake等command-line式的编译器来进行代码的编译，当然我这里主要指的是c/c++。</p><p>Linux段错误时默认不会生成core file，core file的大小被设置为0,可通过<code>ulimit -a</code>查看。所以首先得通过<code>$ulimit -c unlimited</code>进行设置，以便能够生成core file。但在shell里设置的话，只是针对当前会话有效，如果想永久生效，需要将其写到配置文件中，如~/.bashrc, /etc/profile/, /etc/security/limits.conf等中。</p><p>设置完成后，便可通过gdb和gcc来调试程序了。如果一个程序存在段错误问题，那么执行<code>$gcc filename.c -g -o filename</code>进行编译后，在运行<code>filename</code>的时候，会在当前的目录下产生一个core文件。那么这个时候便可以利用core文件进行调试了。调试方法为:</p><pre><code>$gdb [exec file] [core file]
</code></pre><p>有关gdb的详细用法，请参考相关文档去吧。</p><p>段错误实质上是操作系统内核产生的一种中断信号，信号为12。有关信号的知识，请参考操作系统相关的书籍。可通过<code>kill -s SIGSEGV processid</code>来给指定的进程id发送段错误信号，段错误默认处理方法是终止程序的运行。</p></section><div class=post-tags></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/xautjzd rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/xautjzd/ rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2023 © jzd | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>