<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Unix C的文件指针与文件描述符 - Zhengdong.jzd 个人博客</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
AISC C中通常用文件指针FILE *进行文件的操作，如fopen, fclose, fread, fwrite, fscanf, fprintf等函数，都是通过文件指针进行文件的一系列操作；而类Unix系统则大多用文件描述符(file descriptor)进行文件的操作，如open, close, read, write等函数，文件描述符是一个整数，是文件描述符表(file descriptor table)中的索引(文件描述符表其实是维护进程打开的文件)。当进程打开或者创建一个文件，内核便会在此进程对应的文件描述符表中分配一个位置，然后便可通过文件描述符操作文件。"><meta property="og:image" content><meta property="og:title" content="Unix C的文件指针与文件描述符"><meta property="og:description" content="
AISC C中通常用文件指针FILE *进行文件的操作，如fopen, fclose, fread, fwrite, fscanf, fprintf等函数，都是通过文件指针进行文件的一系列操作；而类Unix系统则大多用文件描述符(file descriptor)进行文件的操作，如open, close, read, write等函数，文件描述符是一个整数，是文件描述符表(file descriptor table)中的索引(文件描述符表其实是维护进程打开的文件)。当进程打开或者创建一个文件，内核便会在此进程对应的文件描述符表中分配一个位置，然后便可通过文件描述符操作文件。"><meta property="og:type" content="article"><meta property="og:url" content="https://xautjzd.github.io/posts/2014-05-21-file-pointer-and-file-descriptor-about-c/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-05-21T00:00:00+00:00"><meta property="article:modified_time" content="2014-05-21T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Unix C的文件指针与文件描述符"><meta name=twitter:description content="
AISC C中通常用文件指针FILE *进行文件的操作，如fopen, fclose, fread, fwrite, fscanf, fprintf等函数，都是通过文件指针进行文件的一系列操作；而类Unix系统则大多用文件描述符(file descriptor)进行文件的操作，如open, close, read, write等函数，文件描述符是一个整数，是文件描述符表(file descriptor table)中的索引(文件描述符表其实是维护进程打开的文件)。当进程打开或者创建一个文件，内核便会在此进程对应的文件描述符表中分配一个位置，然后便可通过文件描述符操作文件。"><script src=https://xautjzd.github.io/js/feather.min.js></script>
<link href=https://xautjzd.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://xautjzd.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><div class=main><a href=https://xautjzd.github.io/>Zhengdong.jzd 个人博客</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>Unix C的文件指针与文件描述符</h1><div class=meta>Posted on May 21, 2014</div></div><section class=body><p><img src=/images/20140521.jpg alt></p><p>AISC C中通常用文件指针FILE *进行文件的操作，如fopen, fclose, fread, fwrite, fscanf, fprintf等函数，都是通过文件指针进行文件的一系列操作；而类Unix系统则大多用文件描述符(file descriptor)进行文件的操作，如open, close, read, write等函数，文件描述符是一个整数，是文件描述符表(file descriptor table)中的索引(文件描述符表其实是维护进程打开的文件)。当进程打开或者创建一个文件，内核便会在此进程对应的文件描述符表中分配一个位置，然后便可通过文件描述符操作文件。</p><p>在内核中，每个进程都拥有自己的文件描述符表，表示此进程已打开的所有文件。文件描述符表中每一项其实是一个指针，指向文件表(file table)中用于描述打开文件的数据块——file对象，file对象其实是一个file结构体，有关file结构体的定义，请参考:include/linux.fs.h文件。file结构体包含了文件的打开模式、读写位置等重要信息，当进程打开一个文件时，内核便会创建一个新的file对象。这里要注意的是,file对象不专属于某个进程，不同进程的文件描述符表中的指针可以指向相同的file对象，从而达到共享打开的文件。file对象有引用计数，记录引用这个对象的文件描述符个数，只有当引用计数为0，内核才会销毁该file对象，所以某个进程关闭文件，并不影响与之共享同一个file对象的进程。file对象中包含一个指针，指向dentry对象。dentry对象代表一个独立的文件路径，如果一个文件被打开多次，那么便会建立多个file对象，但他们都指向同一个dentry对象。</p><p>dentry对象又包含一个指向inode对象的指针。inode对象代表一个独立的文件，因为存在硬链接与符号链接，因此不同的dentry对象可以指向同一个inode对象，inode对象包含最终对文件进此操作所需的所有信息，如文件系统类型、文件操作方法、文件权限、访问日期等。</p><p>打开文件后，返回的文件描述符实质上是文件描述符表的索引，根据索引对应的指针访问对应的file对象，然后根据file对象访问对应的dentry，根据dentry对应的inode，从而实现文件的操作。</p><h2 id=转换关系>转换关系</h2><p>有关文件指针与文件描述符及文件路径(包含文件名)之间的转换关系如下：</p><ul><li><p>文件路径->文件指针: filepath&ndash;fopen()&ndash;>FILE *;</p></li><li><p>文件路径->文件描述符: filepath&ndash;open()&ndash;>fd;</p></li><li><p>文件描述符->文件指针: fd&ndash;fdopen()&ndash;>FILE *;</p></li><li><p>文件描述符->文件路径: fd&ndash;readlink(/proc/%getpid()/fd/%fd)&ndash;>filepath;</p></li><li><p>文件指针->文件描述符: FILE *&ndash;fileno()->fd;</p></li></ul><p>下面通过一个例子展示文件描述符与文件指针间的关系:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv, <span style=color:#66d9ef>int</span> argc)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>	FILE <span style=color:#f92672>*</span>fp;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> proclnk[<span style=color:#ae81ff>255</span>];
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>char</span> filepath[<span style=color:#ae81ff>255</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># test.txt为已存在的文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	fp <span style=color:#f92672>=</span> <span style=color:#a6e22e>fopen</span>(<span style=color:#e6db74>&#34;test.txt&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (fp <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>		fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>fileno</span>(fp);
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sprintf</span>(proclnk, <span style=color:#e6db74>&#34;/proc/self/fd/%d&#34;</span>, fd);
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>readlink</span>(proclnk, filepath, <span style=color:#ae81ff>255</span>);
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;fp-&gt;fd-&gt;filepath: %p-&gt;%d-&gt;%s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, fp, fd, filepath);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><div class=post-tags></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/xautjzd rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/xautjzd/ rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2023 © jzd | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>