<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Java jar 是如何执行的? - Zhengdong.jzd 个人博客</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Java 作为一门古老又流行的编程语言，想必大家或多或少都听过，甚至使用过，也有一部分人甚至在生产环境部署过 java 应用。可你了解过 java 程序是如何加载运行的吗？如果你的答案是 yes, 那么建议不用浪费时间花费在已知的知识点了。
下面主要针对 java 可执行 jar(还有有库类型的jar 包，eg: rt.jar) 分析 jar 的加载运行过程，主要包含以下三部分展开:

Java jar 生成
Java jar 内容
Java jar 加载 & 运行
"><meta property="og:image" content><meta property="og:url" content="https://xautjzd.github.io/posts/2020-09-01-how-java-jar-works/"><meta property="og:site_name" content="Zhengdong.jzd 个人博客"><meta property="og:title" content="Java jar 是如何执行的?"><meta property="og:description" content="Java 作为一门古老又流行的编程语言，想必大家或多或少都听过，甚至使用过，也有一部分人甚至在生产环境部署过 java 应用。可你了解过 java 程序是如何加载运行的吗？如果你的答案是 yes, 那么建议不用浪费时间花费在已知的知识点了。
下面主要针对 java 可执行 jar(还有有库类型的jar 包，eg: rt.jar) 分析 jar 的加载运行过程，主要包含以下三部分展开:
Java jar 生成 Java jar 内容 Java jar 加载 & 运行"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-01T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-01T00:00:00+00:00"><meta property="article:tag" content="Java"><meta name=twitter:card content="summary"><meta name=twitter:title content="Java jar 是如何执行的?"><meta name=twitter:description content="Java 作为一门古老又流行的编程语言，想必大家或多或少都听过，甚至使用过，也有一部分人甚至在生产环境部署过 java 应用。可你了解过 java 程序是如何加载运行的吗？如果你的答案是 yes, 那么建议不用浪费时间花费在已知的知识点了。
下面主要针对 java 可执行 jar(还有有库类型的jar 包，eg: rt.jar) 分析 jar 的加载运行过程，主要包含以下三部分展开:
Java jar 生成 Java jar 内容 Java jar 加载 & 运行"><link href=https://xautjzd.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://xautjzd.github.io/css/main.6a0f23ea50fd34b46fee262a5a68e17d458c51a2bc99ba1ba018065de6b180c3.css></head><body><div class=content><header><div class=main><a href=https://xautjzd.github.io/>Zhengdong.jzd 个人博客</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=post-container><div class=post-content><div class=title><h1 class=title>Java jar 是如何执行的?</h1><div class=meta>Posted on Sep 1, 2020</div></div><section class=body><p>Java 作为一门古老又流行的编程语言，想必大家或多或少都听过，甚至使用过，也有一部分人甚至在生产环境部署过 java 应用。可你了解过 java 程序是如何加载运行的吗？如果你的答案是 <code>yes</code>, 那么建议不用浪费时间花费在已知的知识点了。</p><p>下面主要针对 java 可执行 jar(还有有库类型的jar 包，eg: rt.jar) 分析 jar 的加载运行过程，主要包含以下三部分展开:</p><ul><li>Java jar 生成</li><li>Java jar 内容</li><li>Java jar 加载 & 运行</li></ul><h2 id=java-jar-生成>Java jar 生成</h2><p>首先，看下 wikipedia 上对于 <a href=https://en.wikipedia.org/wiki/JAR_(file_format)>jar</a> 的定义:</p><blockquote><p>A JAR (Java ARchive) is a package file format typically used to aggregate many Java class files and associated metadata and resources (text, images, etc.) into one file for distribution</p></blockquote><p>jar 只是用于打包 java 应用的一种格式, 可通过 <code>jar -xf demo.jar</code> 解压查看 jar 内容。</p><p>目前，我们常用的 jar 生成方式:</p><ul><li><a href=https://maven.apache.org/plugins/maven-jar-plugin/>Maven jar plugin</a></li><li><a href=https://docs.gradle.org/current/userguide/java_plugin.html>Gradle java plugin</a></li><li>jdk 自带命令: jar</li></ul><p>下面举一个例子说明。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// com/demo/Hello.java</span>
</span></span><span style=display:flex><span><span style=color:#f92672>package</span> com.demo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hello</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span> (String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;hello, world&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行 <code>javac com/demo/Hello.java</code> 进行编译, 会在 <code>com/demo/</code> 目录下生成 Hello.class 字节码，再执行: <code>java cfe hello.jar com.demo.Hello com/demo/Hello.class</code> 生成可执行 jar，其中 <code>-e</code> 指定程序入口(即: main 函数所在类)，可通过: <code>java -jar hello.jar</code> 执行 jar。</p><h2 id=java-jar-内容>Java jar 内容</h2><p>接着我们可以通过 <code>jar xvf hello.jar</code> 解压 jar 包，看看 jar 包内容，解压后发现多了一个 <code>META-INF/MANIFEST.MF</code> 文件，内容如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Manifest-Version: 1.0
</span></span><span style=display:flex><span>Created-By: 1.8.0_181 (Oracle Corporation)
</span></span><span style=display:flex><span>Main-Class: com.demo.Hello
</span></span></code></pre></div><p>正是因为在 <code>MANIFEST.MF</code> 文件中指定了 <code>Main-Class</code>, jar 才可运行，当然也可在运行时指定 main class: <code>java -cp hello.jar com.demo.Hello</code>。有兴趣的话，可以看看 SpringBoot 打出来的 jar 包 Main-Class 是什么，这里贴个例子:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span>Manifest<span style=color:#f92672>-</span>Version: <span style=color:#ae81ff>1.0</span>
</span></span><span style=display:flex><span>Implementation<span style=color:#f92672>-</span>Title: demo
</span></span><span style=display:flex><span>Implementation<span style=color:#f92672>-</span>Version: <span style=color:#ae81ff>0.0</span><span style=color:#f92672>.</span><span style=color:#ae81ff>1</span><span style=color:#f92672>-</span>SNAPSHOT
</span></span><span style=display:flex><span>Start<span style=color:#f92672>-</span>Class: com<span style=color:#f92672>.</span>demo<span style=color:#f92672>.</span>HelloApplication
</span></span><span style=display:flex><span>Spring<span style=color:#f92672>-</span>Boot<span style=color:#f92672>-</span>Classes: BOOT<span style=color:#f92672>-</span>INF<span style=color:#f92672>/</span>classes<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>Spring<span style=color:#f92672>-</span>Boot<span style=color:#f92672>-</span>Lib: BOOT<span style=color:#f92672>-</span>INF<span style=color:#f92672>/</span>lib<span style=color:#f92672>/</span>
</span></span><span style=display:flex><span>Build<span style=color:#f92672>-</span>Jdk<span style=color:#f92672>-</span>Spec: <span style=color:#ae81ff>1.8</span>
</span></span><span style=display:flex><span>Spring<span style=color:#f92672>-</span>Boot<span style=color:#f92672>-</span>Version: <span style=color:#ae81ff>2.1</span><span style=color:#f92672>.</span><span style=color:#ae81ff>6.</span>RELEASE
</span></span><span style=display:flex><span>Created<span style=color:#f92672>-</span>By: Maven Archiver <span style=color:#ae81ff>3.4</span><span style=color:#f92672>.</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>Main<span style=color:#f92672>-</span>Class: org<span style=color:#f92672>.</span>springframework<span style=color:#f92672>.</span>boot<span style=color:#f92672>.</span>loader<span style=color:#f92672>.</span>JarLauncher
</span></span></code></pre></div><p>jar 包里除了 <code>MANIFEST.MF</code> 与 我们定义的 class 文件外，并没有 java 标准库里的 class(eg: Map, String etc), 那么 jar 在运行时是如何感知标准库的存在呢？这里就涉及了 java class 加载流程。</p><h2 id=java-jar-加载--执行>Java jar 加载 & 执行</h2><p>当我们执行 <code>java -jar hello.jar</code> 时，会启动一个 jvm, 并加载相应的 class 文件至内存，负责加载 class 文件的称为 class loader, java 里包含三类 class loader:</p><ul><li>Bootstrap class loader</li><li>Extensions class loader</li><li>System class loader</li></ul><p>加载顺序为: <code>system class loader -> extensions class loader -> bootstrap loader</code>，首先 system class loader 会委托 extensions class loader 加载，extensions class loader 找不到继续向上，让 bootstrap class loader 加载，若 bootstrap class loader 找不到则 system class loader 加载，找不到就会报: <code>class not found</code>。</p><p>bootstrap class loader 查找路径为: <code>$JAVA_HOME/jre/lib</code>, extensions class loader 查找路径为: <code>$JAVA_HOME/jre/lib/ext/</code>, system class loader 查找路径为: <code>$CLASSPATH</code>(若未指定，默认为当前目录)。classpath可通过 env 指定，也可运行时显式指定。</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/java>Java</a></li></ul></nav></div></div></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/xautjzd rel=me title=GitHub><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github"/></svg></a><a class=border></a><a class=soc href=https://twitter.com/xautjzd/ rel=me title=Twitter><svg class="feather"><use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#twitter"/></svg></a><a class=border></a></div><div class=footer-info>2025 © jzd | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-MD311WEJXY"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MD311WEJXY")}</script></div></body></html>