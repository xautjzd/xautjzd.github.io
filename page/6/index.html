<!doctype html><html><head><meta name=generator content="Hugo 0.111.3"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Zhengdong.jzd 个人博客 | Home</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta property="og:image" content><link rel=alternate type=application/rss+xml href=https://xautjzd.github.io/index.xml title="Zhengdong.jzd 个人博客"><meta property="og:title" content="Zhengdong.jzd 个人博客"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://xautjzd.github.io/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Zhengdong.jzd 个人博客"><meta name=twitter:description content><script src=https://xautjzd.github.io/js/feather.min.js></script>
<link href=https://xautjzd.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://xautjzd.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><div class=main><a href=https://xautjzd.github.io/>Zhengdong.jzd 个人博客</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/tags>Tags</a></nav></header><main class=list><div class=site-description></div><section class=list-item><h1 class=title><a href=/posts/2013-09-12-installing-archlinux-in-virtualbox/>VirtualBox安装ArchLinux系统</a></h1><time>Sep 12, 2013</time><br><div class=description><p>都说ArchLinux很适合折腾，趁今天有时间，就试着安装了一把，不过看ArchLinux的Beginners&rsquo;s Guide，照着其步骤来，结果还是看的云里雾里，看的人头大。便直接上Youtube上找了一个视频，顿时豁然开朗。安装概览如下：</p><p>##ArchLinux Install</p><ol><li>分区</li><li>格式化分区</li><li>挂载分区</li><li>更改安装镜像</li><li>安装基本系统</li><li>生成fstab</li><li>Chroot到新系统</li><li>配置系统</li><li>开启网络服务</li><li>创建初始化ramdisk环境</li><li>设置root密码</li><li>安装配置bootloader</li><li>卸载分区并重启系统</li><li>安装图形用户界面</li></ol><p>详细步骤如下：</p><p>###1. 分区</p><p>虚拟机挂在iso镜像后，然后启动系统，进入后默认进入root提示符，然后输入：</p><pre><code>root#cfdisk
</code></pre><p>进行分区，一般分三个即可。最后分区结果如下：</p><pre><code>dev/sda1 / 8G
dev/sda2 /swap 1G(在空间最后)
dev/sda3 /home 4G
</code></pre><p>每个人的分区情况都可能不同，具体依照自己的分区来决定，以下操作都是根据我的分区来进行。</p>&mldr;</div><a class=readmore href=/posts/2013-09-12-installing-archlinux-in-virtualbox/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2013-09-09-cookies-vs-sessions/>Cookies vs Sessions</a></h1><time>Sep 9, 2013</time><br><div class=description><p>Http是无状态的协议，客户端给服务器发送请求，服务端响应客户端的请求，会话结束。这样两次会话间不便没有任何关联。但有时候需要在会话间进行信息共享，如：购物车，保存用户名与密码等。为此，cookie与session便诞生了,它们的存在就是为了弥补http协议无状态的缺陷。</p><p>cookie与session最大的不同是：cookie保存在用户的浏览器中，而session则保留在服务端。正是这种不同决定了它们的不用使用场合。</p><h2 id=cookie>##Cookie</h2><p>cookie机制是通过扩展http协议来实现的。服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。其实纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器端。</p><p>cookie主要内容包括：Name,Content,Path,Domain,Expires(过期时间)等。Domain与Path一起构成cookie的作用范围。</p><p>若不设置Expires,则默认的cookie生命周期为浏览器会话期间，一旦浏览器关闭，cookie则会被清理掉，这种生命周期为浏览器会话期的cookie被成为会话cookie。会话cookie存储在内存中而不是在硬盘上。</p><p>若设置了Expires,浏览器则会把生成的cookie保存在硬盘上，即使浏览器关闭后再打开，cookie依然有效，直至超过设置的expires。</p><p>另外，session大小有限制，一旦浏览器禁用cookie，则采用cookie的购物网站便不能进行购物，所以这时候得用session了。</p>&mldr;</div><a class=readmore href=/posts/2013-09-09-cookies-vs-sessions/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2013-09-04-lookup-webserver/>查看网站所用Web服务器类型</a></h1><time>Sep 4, 2013</time><br><div class=description>学习Rails的Layout过程中，其中有提到curl，所以便简单的看了下curl的功能。虽说以前学习Shell的过程中也看到过curl,不过没怎么用过，只知道和wget功能类似，只是wget是将请求的web资源下载到本地，而curl则是在shell中显示，至于有什么其他功能也便不清楚。但是今天发现curl其实还可以用来查看website所用的web服务器类型，通过curl -I url-you-want-to-lookup命令查看即可。以下是我查看ruby-china的一个截图： 从中可以发现ruby-china采用的是nginx服务器。至于curl其他的功能慢慢再发掘吧。&mldr;</div><a class=readmore href=/posts/2013-09-04-lookup-webserver/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2013-09-03-activate-user-via-email/>账号注册通过邮箱激活</a></h1><time>Sep 3, 2013</time><br><div class=description>邮箱激活目的 防止用户注册时所填写的信息为虚假信息
邮箱激活的原理 用户注册时，根据用户名、Email及注册时间(精确到ms)等信息通过特定的算法(如:MD5、SHA，最好不可逆)生成相应的信息摘要(也称消息摘要)作为注册的激活码，保存到数据库当中，并且将其作为url的参数，将带有激活码的url链接发送到用户注册的Email中。
只有当用户进入邮箱中并点击该链接后，通过url中的激活码找出数据库中匹配的用户，并将此账号设为“已激活”的状态。
注：此过程没有考虑激活码过期问题，同时信息摘要也可以通过随机数来表示，不一定非要通过用户名等信息生成
Rails代码参考：
http://stackoverflow.com/questions/12805523/activate-user-via-email-in-rails&mldr;</div><a class=readmore href=/posts/2013-09-03-activate-user-via-email/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2013-08-27-from-bash-to-oh-my-zsh/>Bash到oh-my-zsh的转变</a></h1><time>Aug 27, 2013</time><br><div class=description>从开始使用到现在一直使用的bash,虽然以前听过ksh,csh,sh等，但都不曾用过，今年开始zsh便不断地出入在眼前，但没真正见人用过，也不知道效果咋样，所以也没做尝试。
另一个原因是各大linux默认都是bash,说明其功能不错，而且也处于懒的原因，就没折腾。但最近在使用tmux的过程中发现bash的提示符只显示-bash4.2$字样，并没有显示成user@hostname directory，在加上西安rubyist的熟人皓哥强烈推荐，这就坚定了我舍弃bash转到zsh的决心，二话不说，立马上GitHub上找到oh-my-zsh。就照着readme开始尝试，结果出现了错误，Google找到答案，是zsh没有安装才导致，所以就yum install zsh安装了zsh,随后在通过
curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh
安装了oh-my-zsh。不过此时系统默认还是bash,所以还得更改系统默认的shell，方法如下：
###1. 修改/etc/shells文件
先通过$which zsh查看zsh的位置，我zsh位于/usr/bin/zsh。然后再查看/etc/shells中是否含有zsh:
$&lt; /etc/shells grep zsh
如果结果中没有/usr/bin/zsh，则需要手动将/usr/bin/zsh添加到/etc/shells文件中。
###2. 更改默认的shell
通过$chsh -s /usr/bin/zsh更改系统默认shell，退出系统，重新登陆便会发现系统默认的shell已经变为zsh，同时也可以更改zsh默认的主题，在~/.zshrc中更改ZSH_THEME属性即可，其被选的值在oh-my-zsh theme中任选一个即可。
经过以上两步，oh-my-zsh便安装完成。但是写博客时发现rake new_post["xxx"]时出现zsh: no matches found: new_post错误，Google找到答案，只需改为rake 'new_post["xxx"]'即可，原因是zsh会将一些特殊符号当作查找文件的通配符等，根源解决方法是：取消zsh的通配（Glob），即在~/.zshrc中加入alias rake="noglob rake"。
参考：oh-my-zsh官网&mldr;</div><a class=readmore href=/posts/2013-08-27-from-bash-to-oh-my-zsh/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2013-08-26-airline-patched-font-config/>vim-airline插件patched font配置成功</a></h1><time>Aug 26, 2013</time><br><div class=description>前段时间装好了airline插件，但是没呈现应有的效果，原因是没有安装字体。根据官网的提示需要安装powerline的字体，我便照着powerline官网的配置方法来，但是还是没有成功。其原因是我安装了patched fonts，但是没有将terminal的font设置为patched fonts中的一种，所以statusbar会有乱码。下面对安装patched fonts做一个小结。
安装patched fonts方式请参考:powerline字体配置，尽管文档很详细，但是还是重复一下：
1.Download patched fonts
$mkdir ~/.fonts新建一个font文件夹，然后$cd ~/.fonts进入.fonts文件夹。$git clone git@github.com:Lokaltog/powerline-fonts.git将powerline的patched fonts拷贝到~/.fonts目录下，目录结构如下图：
2.Install the patched fonts to your System
运行$fc-cache -vf ~/.fonts安装patched fonts到系统中
3.Set Terminal fonts
设置Terminal字体非常重要，我初次配置时，安装patched fonts，但是由于没有set terminal font,所以statusbar显示乱码。设置方法如下：
Edit——Profiles——Default(Edit)——General——Font，选择~/.fonts/powerline下的某一种即可(可选范围一定要在刚才下载的patched fonts中选一种，否则乱码。)，当然也可以采取powerline font installing中的另一种方式，不过我没做尝试，有兴趣的朋友try it。配置截图如下：
最后可以在~/.vimrc中更改airline的theme。更改方式如下：
let g:airline_theme="molokai" &mldr;</div><a class=readmore href=/posts/2013-08-26-airline-patched-font-config/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2013-08-25-vim-folding-and-unfolding/>vim文件的折叠与展开方式</a></h1><time>Aug 25, 2013</time><br><div class=description>最近一直在用Vim学习Ruby,但是一直有个问题困扰：
那就是文件无法折叠，但是我记得以前看过Vim的视频，里面见别人用到了折叠与展开。文件比较小时，此功能便无用，但一旦文件量大时，折叠与展开便显得尤为重要了。
折叠的方式有以下几种：
manual indent syntax marker expr diff ###1. Manual method
vim默认的折叠方式是此种方式，不需要设置即可。要启用其他方式还得采用:set foldmethod=xxx或者:set fdm=xxx来设置。
使用方法：
v或者V进入visual mode,然后选中要折叠的文字，按zf便可折叠，折叠后按za或者zO便展开。
同时也可以通过zfnj的方式将接下来的n行折叠。类似也有zfnk等;zR则打开所有的折叠。总结下来就是：
zf => create a fold za => unfold zf#j => fold down # lines zf#k => fold up #lines zR => unfold all ###2. Indent method
缩进方式主要是根据代码缩进的方式来折叠/展开代码。要使用缩进方式，则需要做配置，:set foldmethod=indent或者在~/.vimrc中配置：set foldmethod=indent。
其快捷键如下： zM => fold all zR => unfold all za => fold/unfold
###3. Syntax method
采用syntax方式，则只需如下配置即可：
:set fdm=syntax 按键方式与上述相似
###4. Marker method&mldr;</div><a class=readmore href=/posts/2013-08-25-vim-folding-and-unfolding/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2013-08-20-linux-activity-sponsoring/>Linux活动发起</a></h1><time>Aug 20, 2013</time><br><div class=description>独乐乐不如众乐乐，独自一人埋头苦学不如一群兴趣相投之人的一起交流。记得以前大一大二时，希望能有一个领路人领着自己学习，帮自己找准学习的方向，毕竟当时太年轻，太多东西不了解，所以不知道软件这行业该学习什么，哪些东西比较有兴趣，一切源于自己接触的太少，身边也没有可交流之人。再加上学校大一大二和大三大四分隔新旧两校区，交流就更少。
正是因为自己的这些经历，然后再加上近来参加西安的rubyist party，促使了我组建Linux小组并且定期举办活动的冲动。一个人的埋头苦学，所见所闻永远局限在某个狭小的空间，只有走出去，与他们交流才能拓宽自己的知识面，提升自己的认知度，也算是多了一些朋友，多了一些交流。正所谓话不投机半句多，与自己志不同道不和的人交流真是有点对牛弹琴的感觉。所以要交流得找兴趣相投志同道合之人。
打算成立的小组规模大致10人左右，无需太多，也不希望有滥竽充数的现象。所以希望小组成员能满足以下条件：
对软件感兴趣 熟悉Linux(基本操作一般没问题) Vim | Emacs 具备以下更佳：
Git Ruby/Python/Lisp/Scala/Prolog 个人博客 初期打算:
每周一次Party（主要技术交流） 有兴趣的学习请联系我，联系方式：
新郎微薄：xautjzd 其他联系方式见我的About&mldr;</div><a class=readmore href=/posts/2013-08-20-linux-activity-sponsoring/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2013-08-18-difference-between-symbol-and-string/>Ruby中symbol与string的区别</a></h1><time>Aug 18, 2013</time><br><div class=description>记得当初学习Ruby基本语法时，还为Symbol与String的异同纠结了好久，后来经过一段时间的摸索，大致有了了解，但让我给他人解释，这点我还是办不到。但是今天看到了一篇博文,让我彻底明白他们的区别。
symbol定义 Symbol其实就是string加上前缀：。
二者异同点 其实Symbol与String本质相同，是string 的两种不同呈现方式。由于受SmallTalk影响，Ruby一切皆对象。所以每次给string赋值，name="xautjzd"其实都是在内存中创建一个新对象。每次创建的对象的object_id都不相同。
而symbol则不同，symbol创建一次即可。以后所有的操作都是指向先前创建的对象。所以object_id相同。
不同点大致有三：
symbol为常量，值不能改变。 多次使用同一个symbol,object_id相同，而多次使用string,每个对象有不同的object_id。 String的方法,eg:#upcase,#split不能用于Symbol。 参考网址 http://www.gaurishsharma.com/2013/04/understanding-differences-between-symbols-strings-in-ruby.html(http://www.gaurishsharma.com/2013/04/understanding-differences-between-symbols-strings-in-ruby.html)&mldr;</div><a class=readmore href=/posts/2013-08-18-difference-between-symbol-and-string/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/2013-08-18-vim-learning-resource/>Vim学习资源</a></h1><time>Aug 18, 2013</time><br><div class=description><h3 id=实用的快捷方式>实用的快捷方式</h3><ul><li>gf 快速跳转到定义</li><li><code>&lt;C + 6></code> 返回到上次编辑的文档</li><li>% 括号匹配{}<a href></a></li><li><code>#/*,g#/g*</code> 向前/向后搜索光标所在的词</li><li>gi 跳转到上次编辑的位置</li><li>gi 显示光标所在字符的编码</li><li>gH 开始选择行模式</li><li>vi" 选中"之间的文本(不包括")</li><li>vi{ 选中{之间的文本（不包括{）</li><li>ci( 改变之间的文本</li><li>di[ 删除[之间的文本(不包括[)</li><li>da[ 删除[之间的文本(包括[),ca、va类似</li><li>C 修改至行尾</li><li>D 删除至行尾</li></ul>&mldr;</div><a class=readmore href=/posts/2013-08-18-vim-learning-resource/>Read more ⟶</a></section><ul class=pagination><span class="page-item page-prev"><a href=/page/5/ class=page-link aria-label=Previous><span aria-hidden=true>← Prev</span></a></span>
<span class="page-item page-next"><a href=/page/7/ class=page-link aria-label=Next><span aria-hidden=true>Next →</span></a></span></ul></main><footer><div style=display:flex><a class=soc href=https://github.com/xautjzd rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/xautjzd/ rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a></div><div class=footer-info>2023 © jzd | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>